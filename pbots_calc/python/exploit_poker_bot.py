import pbots_calc
import sys
import pandas as pd
import numpy as np
import pickle
import random
from poker.hand import Hand, Combo, Range
import poker.hand as poker_hand
import matplotlib.pyplot as plt

file = open("equities.pickle", "rb")
equities = pickle.load(file)
cards = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2']

def random_hand(): #generates a random poker hand combo
    percent = random.random()
    if percent < 3/51:
        hand = str(random.choice(poker_hand.PAIR_HANDS))
    elif percent < 15/51:
        hand = str(random.choice(poker_hand.SUITED_HANDS))
    else:
        hand = str(random.choice(poker_hand.OFFSUIT_HANDS))
    return hand

def play_as_caller(pot, stack, call_range, jam_range, assumed_jam_range, rounds): #fictitious play to test exploitative strategy
    jammed = 0
    ev_data = [0]
    range_ev_data = []
    optimal_jam_range = assumed_jam_range.copy()

    for i in range(1, rounds + 1):
        call_range = optimal_call(pot, stack, assumed_jam_range)
        range_ev_data.append(range_ev(pot, stack, call_range, jam_range))
        call_hand = random_hand()
        jam_hand = random_hand()
        print("Round", i, call_hand, jam_hand)
        ev = handvhand(call_hand, jam_hand) * (stack * 2 + pot) - stack
        if jam_hand[-1] == 'o':
            jam_hand = jam_hand[1] + jam_hand[0] + 'o'
        if call_hand[-1] == 'o':
            call_hand = call_hand[1] + call_hand[0] + 'o'
        if jam_range.at[jam_hand[0], jam_hand[1]] > random.random(): #if hand is in jam range, jam
            jam = True
        else:
            jam = False
        if call_range.at[call_hand[0], call_hand[1]] > random.random(): #if hand is in call range, call
            call = True
        else:
            call = False

        exploit = 2 #decides which exploitative strategy to use
        if exploit == 1: #builds opponent range through hands seen
            for y, card1 in enumerate(cards):
                for x, card2 in enumerate(cards[y+1:]):
                    assumed_jam_range.at[card1, card2] = round(assumed_jam_range.at[card1, card2] * ((1326 - 4) / 1326), 3)
                    assumed_jam_range.at[card2, card1] = round(assumed_jam_range.at[card2, card1] * ((1326 - 12) / 1326), 3)
                assumed_jam_range.at[card1, card1] = round(assumed_jam_range.at[card1, card1] * ((1326 - 6) / 1326), 3)

            if call == True and jam == True: #cards are seen
                assumed_jam_range.at[jam_hand[0], jam_hand[1]] = 1
            elif jam == False: #caller wins
                ev = pot
            elif jam == True and call == False: #jammer wins
                ev = 0
        elif exploit == 2: #builds opponent range through calculated jam percentage
            if call == True and jam == True: #cards are seen
                jammed += 1
            elif jam == False: #caller wins
                ev = pot
            elif jam == True and call == False: #jammer wins
                jammed += 1
                ev = 0
            assumed_jam_range = build_jam_range(pot, stack, call_range, jammed/i)
            if i < 100:
                assumed_jam_range = np.add(assumed_jam_range * i/100, optimal_jam_range * (100-i) / 100)
        elif exploit == 3: #do both
            for y, card1 in enumerate(cards):
                for x, card2 in enumerate(cards[y+1:]):
                    assumed_jam_range.at[card1, card2] = round(assumed_jam_range.at[card1, card2] * ((1326 - 4) / 1326), 3)
                    assumed_jam_range.at[card2, card1] = round(assumed_jam_range.at[card2, card1] * ((1326 - 12) / 1326), 3)
                assumed_jam_range.at[card1, card1] = round(assumed_jam_range.at[card1, card1] * ((1326 - 6) / 1326), 3)
            if call == True and jam == True: #cards are seen
                assumed_jam_range.at[jam_hand[0], jam_hand[1]] = 1
                jammed += 1
            elif jam == False: #caller wins
                ev = pot
            elif jam == True and call == False: #jammer wins
                jammed += 1
                ev = 0
            expected_jam_range = build_jam_range(pot, stack, call_range, jammed/i)
            if i < 100:
                assumed_jam_range = np.add(expected_jam_range * i/100, assumed_jam_range * (100-i) / 100)
        ev_data.append((ev_data[-1] * (i-1) + ev) / i )
        print("opponent's predicted percentage:", percentage(assumed_jam_range))
    ev_data.pop(0)
    return(ev_data, range_ev_data)

def range_ev(pot, stack, call_range, jam_range): #calculates the ev of the entire range
    jamev = jam_ev(pot, stack, call_range)
    ev = 0
    for y, card1 in enumerate(cards):
        for x, card2 in enumerate(cards[y+1:]):
            ev += 4 * jamev.at[card1, card2] * jam_range.at[card1, card2]
            ev += 12 * jamev.at[card2, card1] * jam_range.at[card2, card1]
        ev += 6 * jamev.at[card1, card1] * jam_range.at[card1, card1]
    return pot - (ev/1326)

def build_random_range(expected_percent): #builds a random range based on expected_percent with no regards for hand strength
    range = empty_range()
    combos = expected_percent * 1326
    total_combos = 0
    while True:
        hand = random_hand()
        if hand[-1] == 's':
            total_combos += 4
            range.at[hand[0], hand[1]] = 1
        elif hand[-1] == 'o':
            total_combos += 12
            range.at[hand[1], hand[0]] = 1
        else:
            total_combos += 6
            range.at[hand[0], hand[0]] = 1
        if total_combos >= combos:
            if hand[-1] == 's':
                range.at[hand[0], hand[1]] = (4 - (total_combos - combos)) / 4
            elif hand[-1] == 'o':
                range.at[hand[1], hand[0]] = (12 - (total_combos - combos)) / 12
            else:
                range.at[hand[0], hand[0]] = (6 - (total_combos - combos)) / 6
            break
    return range

def build_jam_range(pot, stack, call_range, expected_percent): #generates a jam range containing the highest EV hands of a certain percentage played
    ev_rank = []
    call_percent = percentage(call_range)
    jam_range = empty_range()
    for y, card1 in enumerate(cards): #generates an array of hand and it's equity
        for x, card2 in enumerate(cards[y+1:]):
            ev_rank.append((f"{card1}{card2}s", (1 - call_percent) * pot + call_percent * (handvrange(f"{card1}{card2}s", call_range) * (stack * 2 + pot)  - stack)))
            ev_rank.append((f"{card2}{card1}o", (1 - call_percent) * pot + call_percent * (handvrange(f"{card1}{card2}o", call_range) * (stack * 2 + pot)  - stack)))
        ev_rank.append((f"{card1}{card1}", (1 - call_percent) * pot + call_percent * (handvrange(f"{card1}{card1}", call_range) * (stack * 2 + pot)  - stack)))
    ev_rank = sorted(ev_rank, key=lambda x: x[1], reverse = True) #ranks the array of hand equities
    combos = expected_percent * 1326
    total_combos = 0
    for item in ev_rank: #adds hands into range from max ev to lowest until percentage is reached
        if item[0][-1] == 's':
            total_combos += 4
        elif item[0][-1] == 'o':
            total_combos += 12
        else:
            total_combos += 6
        jam_range.at[item[0][0], item[0][1]] = 1
        if total_combos >= combos:
            if item[0][-1] == 's':
                over = (4 - (total_combos - combos)) / 4
            elif item[0][-1] == 'o':
                over = (12 - (total_combos - combos)) / 12
            else:
                over = (6 - (total_combos - combos)) / 6
            jam_range.at[item[0][0], item[0][1]] = over
            break
    return jam_range

def gto(pot, stack, iter): #generates a nash equillibrium gto jam and call strategy through fictitious play
    optcall = empty_range()
    optcall[optcall == 0] = .5
    optjam = empty_range()
    optjam[optjam == 0] = .5

    for t in range(1, iter + 1): #rounds of play
        print("Round", t)
        jam_range = optimal_jam(pot, stack, optcall)
        for y, card1 in enumerate(cards): #updates gto range
            for x, card2 in enumerate(cards):
                optjam.at[card1, card2] = (1 - 1/t) * optjam.at[card1, card2] + 1/t * jam_range.at[card1, card2]
        call_range = optimal_call(pot, stack, optjam)
        for y, card1 in enumerate(cards): #updates gto range
            for x, card2 in enumerate(cards):
                optcall.at[card1, card2] = (1 - 1/t) * optcall.at[card1, card2] + 1/t * call_range.at[card1, card2]
    jam_range = optimal_jam(pot, stack, call_range)
    call_range = optimal_call(pot, stack, jam_range)
    return call_range, jam_range

def optimal_jam(pot, stack, range): #creates a pure strategy range against opponent range from jam_ev
    jamev = jam_ev(pot, stack, range)
    jam_range = jamev.copy()
    jam_range[jam_range > 0] = 1
    jam_range[jam_range <= 0] = 0
    return jam_range

def jam_ev(pot, stack, range): #returns a range containing ev for each hand against opponent range
    optev = empty_range()
    percent = percentage(range)
    for y, card1 in enumerate(cards): #loops through all possible hands
        for x, card2 in enumerate(cards[y+1:]):
            optev.at[card1, card2] = (1 - percent) * pot + percent * (handvrange(f"{card1}{card2}s", range) * (stack * 2 + pot)  - stack)
            optev.at[card2, card1] = (1 - percent) * pot + percent * (handvrange(f"{card1}{card2}o", range) * (stack * 2 + pot)  - stack)
        optev.at[card1, card1] = (1 - percent) * pot + percent * (handvrange(f"{card1}{card1}", range) * (stack * 2 + pot)  - stack)
    return optev

def optimal_call(pot, stack, range): #creates a pure strategy range against opponent range from call_ev
    callev = call_ev(pot, stack, range)
    call_range = callev.copy()
    call_range[call_range > 0] = 1
    call_range[call_range <= 0] = 0
    return call_range

def call_ev(pot, stack, range): #returns a range containing ev for each hand against opponent range
    optev = empty_range()
    for y, card1 in enumerate(cards): #loops through all possible hands
        for x, card2 in enumerate(cards[y+1:]):
            optev.at[card1, card2] = handvrange(f"{card1}{card2}s", range) * (stack * 2 + pot) - stack
            optev.at[card2, card1] = handvrange(f"{card1}{card2}o", range) * (stack * 2 + pot) - stack
        optev.at[card1, card1] = handvrange(f"{card1}{card1}", range) * (stack * 2 + pot) - stack
    return optev

def handvrange(hand, range): #returns hand equity versus entire poker range
    ev = 0
    total = 0
    for y, card1 in enumerate(cards):
        for x, card2 in enumerate(cards[y+1:]):
            ev += 4 * handvhand(hand, f"{card1}{card2}s") * range.at[card1, card2]
            total += 4 * range.at[card1, card2]
            ev += 12 * handvhand(hand, f"{card1}{card2}o") * range.at[card2, card1]
            total += 12 * range.at[card2, card1]
        ev += 6 * handvhand(hand, f"{card1}{card1}") * range.at[card1, card1]
        total += 6 * range.at[card1, card1]
    ev = ev / total
    return ev

def handvhand(hand1, hand2): #returns handvhand equity from precomputed dictionary
    return equities[(hand1, hand2)]

def percentage(range): #calculated percentage of hands played in range
    combos = 0
    for y, card1 in enumerate(cards):
        for x, card2 in enumerate(cards[y+1:]):
            combos += 4 * range.at[card1, card2]
            combos += 12 * range.at[card2, card1]
        combos += 6 * range.at[card1, card1]
    return combos / 1326

def empty_range(): #returns an empty 13x13 Poker Range
    range = pd.DataFrame(np.zeros((13,13)), columns = cards, index = cards)
    return range

def handvrange_pbots(hand, range): #deprecated pbots_calc handvrange calculator
    range = ",".join(range)
    r = pbots_calc.calc(f"{hand}:{range}", "", "", 1000000)
    return r.ev[0]
    
if __name__ == "__main__":
    print("no usage")
